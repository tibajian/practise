# 目录
## 数据
- 数据分类
  - 基本类型
  - 引用类型
    - object:任意
      - 实例：即实例对象，根据类型创建的实例对象
      - 类型：类型对象，如构造函数
    - function:可执行的对象
    - array:带下标的有序数据
- 数据判断
  - typeof
    - 判断后返回字符串表达
    - 不能判断: null(判断为object)\undefined\object\array
  - instanceof (A instance B判断对象实例.通过隐式原型，只要B的显式原型对象在A的隐式原型链上返回true)
    - 判断对象具体类型
  - === \ ==
- 问题
  - undefined与null？
    - **定义未赋值**、定义了但值为null
  - 什么时候为null？
    - var a = null \\表明将要赋值为对象
    - b = null \\回收垃圾对象
  - 严格区分数据类型与变量类型
    - 数据的类型：基本类型和对象类型
    - 变量的类型（变量内存值的类型）：基本类型（保存的是基本数据）和引用类型（保存对象的地址）
## 数据、变量、内存
- 数据：存储在内存中代表信息的内容，即特定的01组合
- 内存：内存条通电后的可存储数据的空间。变量对应的内存中2个数据分别为变量名（地址）和变量值。内存：堆（全局变量、局部变量）和栈（对象）
- 变量：可变化的量，有变量名和变量值组成。变量对应着一块内存，变量名用来查找对应的内存，变量值即内存中保存的数据
- 变量赋值传递
  - 看两个变量是否指向同一个对象
  - 看变量是否修改了内容（即对象地址，即创建了新对象，而另一个变量没改变
  - 变量传递的是变量的内容（包括基本数据和引用即地址）
- 函数调用时传递变量的是值传递还是引用传递
- 局部变量在调用后被释放，（如果指向对象）那这个变量指向的对象成为垃圾对象后被垃圾回收机制回收
## 对象
- 对象
  - 多个数据的封装体
  - 用来保存多个数据的容器
  - 一个对象代表现实中的一个数据
- 为什么用
  - 统一管理多个数据
- 组成
  - 属性名是字符串、属性值是任意类型
- 使用 [](通用) \ .
  - 不能用 .
    - 1.属性名有特殊字符：-
    - 2.变量名不确定：
        ```js
        var name = 'tom'
        var age = 18
        p = {}
        // 结果为 'name: 18'
        p.name = 18
        // 结果为 'tom: 18'
        p[name] = 18
        ```
## 函数
- 函数 实现特定功能的N条语句的封装体；只有函数能执行
- 提高代码复用、便于阅读交流
- 函数声明、表达式；区别：变量提升
- 执行调用
  - fun() 普通调用
  - obj.fun() 方法调用
  - new fun() new调用
  - fun.call/apply(obj) 临时让fun成为obj的方法调用 call和apply让一个函数成为任意指定对象的方法进行调用
- 回调函数
  - 自己定义的没有调用但是执行了
  - 如：dom事件回调、定时器回调、ajax请求回调函数、生命周期回调函数
- IIFE immediately-invoked function expression
  - 立即执行函数表达式\匿名函数自调用 (function (){})()
  - 作用：隐藏实现、不污染全局命名空间、用来编写模块
- this
  - 所有函数都有
  - **函数本质上都是通过某个对象来调用的，如没有直接指定对象就是window调用**
  - **值为调用函数的当前对象**
## 函数高级
- 原型与原型链
  - 原型
    - prototype
      - 每个函数都有一个prototype属性，（属性值为object的地址）。在定义函数时添加的（就是 this.prototype = {}）
      - 默认指向一个object空对象（没有我加的属性）（即原型对象）
      - 用来给实例对象添加公共的方法或属性
      - 原型对象有一个属性constructor，指向函数对象
    - 显式原型与隐式原型
      - 每个函数都有一个prototype属性即显式原型，默认值为空object对象
      - 每个实例对象都有一个__proto__ 为隐式原型（属性），默认值为构造函数的prototype属性值。创建对象时添加的（就是将构造函数的prototype值赋过来）
    - 属性（方法）添加时通过显式原型、访问时通过隐式原型、
  - 原型链(隐式原型链)
    - 原型链——通过这种原型方式连接（沟通）所有的相关对象
    - 查找属性——自查——通过隐式原型属性找上一个原型对象直到隐式原型为null（Object.prototype.__proto__ = null）（返回undefined）
    - 所有函数的隐式原型都是Functuion构造函数的显示原型Function
      ```JS
      //函数的显示原型指向的对象：默认为空Object实例对象（但Object不是）
      //所有函数都是Function的实例，包括Function
      //Object为原型链尽头
      ```
  - 原型继承
## 上下文
- 变量提升、函数提升
- 全局代码、函数代码
- 全局执行上下文
  - 1、在执行全局代码前将window确定为全局执行上下文
  - 2、对全局数据预处理
    - var定义的全局变量（此时值为undefined），为window的属性
    - function声明的全局函数（值为函数内容），为window的方法
    - this，为window
  - 3、开始执行全局代码
- 函数执行上下文
  - 调用函数、执行函数前，创建函数执行上下文对象（在内存栈中创建一片空间）
  - 对局部数据预处理（同上）
    - 形参、arguments、var、function、this
  - 执行
- 执行上下文栈
  - 执行全局代码前，JS引擎会创建一个栈来管理所有的执行上下文对象
  - 全局执行上下文创建后，添加到栈中
  - 在函数执行上下文创建后，添加到栈
  - 当前函数执行完毕后，将栈顶的对象出栈
  - 所有代码执行完后，栈中只剩window
- 作用域、链
- 闭包
  - 当一个**嵌套**的函数**引用**嵌套外面的函数的变量时，产生闭包
  - 闭包是嵌套的内部函数
  - 闭包是包含被引用变量的对象
  - 闭包存在于嵌套的函数内部
  - 产生多少闭包看外部函数调用多少次
  - 闭包产生看外部函数调用时，内部函数已定义。即外部有变量指向函数内部函数
  - 消失看内部函数成为垃圾对象。即指向消失
  - 常见的闭包
    - 将函数作为另一个函数的返回值
    - 将函数作为实参传递给另一个函数调用
  - 作用，1-使函数内部的变量在函数执行后不释放；2-让函数外部可以操作函数内部的数据
- js模块（闭包应用）
  - 特定功能的js文件
  - 所有数据和功能封装在一个函数（或对象）内部、（多个函数时封装到一个对象里）
  - 只向外暴露n个函数/对象
  - 使用时，通过暴露的函数调用
  - 产生闭包直接调用外部函数或回调函数（暴露对象添加给window）
- 闭包缺点
  - 内存泄漏——内存没有及时释放导致占用过多（意外的全局变量、不关闭定时器或回调函数、闭包）、内容溢出——运行程序需要的内存不够，产生错误报告
  - 内存泄漏解决，让闭包成为垃圾对象释放，指向闭包的变量值变成 null
- 继承模式
  - 原型链继承——子类型的原型为父类型的一个实例对象、让子类型的原型的constructor指向子类型
  - 借用构造函数继承（假）——call
  - 组合（上面两个）继承——原型链继承得到方法，call继承得到属性
## 进程、线程
- 进程——程序的一次执行，所占有的一片独立内存
- 线程——进程的一个独立执行单元
- js引擎先执行初始化代码（包含一些特殊代码：定时器、绑定监听、Ajax请求），然后执行回调代码
- 浏览器内核
  - 主线程——只能主线程更新界面
    - js引擎模块
    - HTML、css文档解析模块
    - Dom\css模块
    - 布局、渲染
  - 分线程
    - 定时器模块
    - DOM事件模块
    - 网络请求模块
- **事件循环（驱动）模型**
  - 执行栈
  - 内核（js引擎模块、其他模块）
  - 任务、消息、事件队列（都是回调函数）
  - 事件轮询（主线程初始化代码执行完。循环取出队列的任务放入执行栈）
- 请求响应模型
- H5 Web Workers多线程
